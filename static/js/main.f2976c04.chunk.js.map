{"version":3,"sources":["utils/isPowerOf2.ts","Components/Bit/Bit.tsx","utils/dec2binPadded.ts","utils/zeroPadString.ts","utils/dec2bin.ts","utils/zeroOrOne.ts","utils/generateData.ts","utils/getCorrectParityBitValues.ts","App.tsx","utils/validateDataArray.ts","serviceWorker.ts","index.tsx"],"names":["isPowerOf2","num","Bit","getColorClassName","props","bitIndex","doubleError","errorIndex","getOpacityClassName","mousedOverBitIndex","length","this","absolutePositioned","bit","height","isCell","numRows","numColumns","onClickBit","onMouseOverBit","paddedBinaryLength","showBinary","width","colorClassName","opacityClassName","absolutePosition","position","left","toString","top","Math","floor","className","onClick","e","onMouseOver","style","paddingBottom","string","right","zeroPadString","React","Component","zeroOrOne","number","generateData","numberBits","data","push","random","correctParityBitValues","powerOf2","parityBitIndex","pow","paritySum","compareBitIndex","getCorrectParityBitValues","forEach","value","reduce","accumulator","currentValue","App","dataContainerInnerRef","calculations","memoize","ceil","sqrt","regularParityBits","filter","map","reverse","totalNumParityBits","parity","validateDataArray","state","efficiency","toFixed","log","getBitDimensions","dataContainerInnerWidth","windowInnerWidth","dimension","min","bitHeight","bitWidth","generateNewData","setState","getMousedOverText","element","index","key","getRegularParityBitsExplanation","sharedBitProps","Fragment","onMouseLeave","regularParityBit","swapIncorrectBit","disabled","highlightBit","resize","current","clientWidth","switchBit","dataCopy","slice","createRef","window","addEventListener","removeEventListener","innerWidth","id","ref","newDimension","type","step","onChange","parseInt","target","parityBit","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.f2976c04.chunk.js","sourcesContent":["/**\n * given a number, return true/false whether it is a power of 2, including 1, excluding 0\n * taken from https://stackoverflow.com/questions/1053582/how-does-this-bitwise-operation-check-for-a-power-of-2/1053594#1053594\n * @param  num input number\n * @return     true/false whether the number is a power of 2\n */\nexport default function isPowerOf2(num:number) {\n  if(num === 0) {\n    return false\n  }\n\n  return !(num & (num - 1)) //bitwise AND the number and one less than it\n}\n","import React from 'react';\n\nimport dec2binPadded from \"utils/dec2binPadded\"\nimport isPowerOf2 from \"utils/isPowerOf2\"\nimport \"./bit.scss\"\n\ninterface BitProps {\n  absolutePositioned:boolean,\n  bit: number,\n  bitIndex: number,\n  doubleError: boolean,\n  errorIndex: number,\n  height: number,\n  isCell: boolean,\n  mousedOverBitIndex:number,\n  numColumns: number,\n  numRows: number,\n  onClickBit: Function,\n  onMouseOverBit: Function,\n  paddedBinaryLength: number,\n  showBinary?: boolean,\n  width: number,\n}\n\ninterface AbsolutePosition {\n  position: \"absolute\" | \"relative\",\n  left?: string,\n  top?: string,\n}\n\nclass Bit extends React.Component<BitProps,{}> {\n  getColorClassName = () => {\n    const {\n      bitIndex,\n      doubleError,\n      errorIndex,\n    } = this.props\n\n    if(bitIndex === 0) { //if this is the 0th cell\n      return \"colorZerothBit\"\n    }\n    else if(doubleError===false && errorIndex===bitIndex) {\n      return \"colorErrorBit\"\n    }\n    else if(isPowerOf2(bitIndex)) { //if this is a parity bit\n      // if( //if this is a parity bit for the moused over cell\n      //   mousedOverBitIndex>=0\n      //   && bitIndex & mousedOverBitIndex\n      // ) {\n      //   return \"relatedParityBit\"\n      // }\n\n      return \"colorParityBit\"\n    }\n    // else if( //if the moused over cell is a parity bit for this cell\n    //   mousedOverBitIndex>=0 //there is a cell being moused over\n    //   && isPowerOf2(mousedOverBitIndex) //the moused over cell is a parity bit\n    //   && bitIndex & mousedOverBitIndex //the ANDed bitwise operation produces a number\n    // ) {\n    //   return \"colorDataBit\" //return \"coveredByParityBit\"\n    // }\n    // else if(bitIndex === mousedOverBitIndex) { //if this is the cell being moused over\n    //   return \"colorMousedOver\"\n    // }\n\n    return \"colorDataBit\"\n  }\n\n  getOpacityClassName = () => {\n    const {\n      bitIndex,\n      mousedOverBitIndex,\n    } = this.props\n\n    if(bitIndex === 0) { //if this is the 0th cell\n      if(mousedOverBitIndex > 0) {\n        return \"opacityDimmed\"\n      }\n      return \"\"\n    }\n    else if( //if this is a parity bit for the moused over cell\n      isPowerOf2(bitIndex)\n      && mousedOverBitIndex>=0\n      && bitIndex & mousedOverBitIndex\n    ) {\n      return \"\"\n    }\n    else if( //if the moused over cell is a parity bit for this cell\n      mousedOverBitIndex>=0 //there is a cell being moused over\n      && isPowerOf2(mousedOverBitIndex) //the moused over cell is a parity bit\n      && bitIndex & mousedOverBitIndex //the ANDed bitwise operation produces a number\n    ) {\n      return \"\"\n    }\n    else if(\n      mousedOverBitIndex >= 0\n      && mousedOverBitIndex !== bitIndex\n    ) {\n      return \"opacityDimmed\"\n    }\n\n    return \"\"\n  }\n\n  render() {\n    const {\n      absolutePositioned,\n      bit,\n      bitIndex,\n      height,\n      isCell,\n      numRows,\n      numColumns,\n      onClickBit,\n      onMouseOverBit,\n      paddedBinaryLength,\n      showBinary,\n      width,\n    } = this.props\n\n    const colorClassName = this.getColorClassName()\n    const opacityClassName = this.getOpacityClassName()\n\n    if(isCell) {\n      const absolutePosition:AbsolutePosition = {position: \"relative\"}\n      if(absolutePositioned) {\n        absolutePosition.position = \"absolute\"\n        absolutePosition.left = (100 * (bitIndex % numColumns) / numColumns).toString()+\"%\" //TODO memoize this\n        absolutePosition.top = (100 * Math.floor(bitIndex/numColumns) / numRows).toString()+\"%\"\n      }\n\n      return (\n        <span\n          className={`bit cell ${colorClassName} ${opacityClassName}` }\n          onClick={e => onClickBit(bitIndex)}\n          onMouseOver={e => onMouseOverBit(bitIndex)}\n          style={{\n            height: height - 2,\n            width: width - 2,\n            ...absolutePosition,\n          }}\n        >\n          <div className=\"value\" style={{\n            paddingBottom: showBinary ? \"0.25em\" : \"0\"\n          }}>{bit}</div>\n          <div className=\"binaryBitIndex\">{showBinary ? dec2binPadded(bitIndex, paddedBinaryLength) : null}</div>\n          <div className=\"bitIndex\">{bitIndex}</div>\n        </span>\n      )\n    }\n\n    return (\n      <span\n        className={`bit messageBit ${colorClassName} ${opacityClassName}`}\n        onClick={e => onClickBit(bitIndex)}\n        onMouseOver={e => onMouseOverBit(bitIndex)}\n      >\n        {bit}\n      </span>\n    )\n  }\n}\n\nexport default Bit\n","import dec2bin from \"utils/dec2bin\"\nimport zeroPadString from \"utils/zeroPadString\"\n\n/**\n * given a number a desired length, return the zero padded binary string representation\n * @param  number input number\n * @param  length desired string length to zero pad to\n * @return        zero padded binary string\n */\nexport default function dec2binPadded(number:number, length:number) {\n  return zeroPadString(dec2bin(number), length)\n}\n","/**\n * given a string and desired length, zero pad the string if it is shorted than the desired length\n * @param  string input string\n * @param  length desired length\n * @param  right  if true, pad on the right, else pad on the left\n * @return        zero padded string\n */\nexport default function zeroPadString(string:string, length:number, right?:boolean) {\n  while(string.length < length) {\n    if(right) {\n      string = string + \"0\"\n    }\n    else {\n      string = \"0\" + string\n    }\n  }\n\n  return string\n}\n","/**\n * converts a base 10 number into it's binary string representation\n * taken from https://stackoverflow.com/questions/9939760/how-do-i-convert-an-integer-to-binary-in-javascript\n * @param  dec base 10 number\n * @return     binary string representation\n */\nexport default function dec2bin(dec:number) {\n  return (dec >>> 0).toString(2)\n}\n","/**\n * return 1 if the number is greater than 0, else return 0\n * @param  number input number\n * @return        0 or 1\n */\nexport default function zeroOrOne(number:number) {\n  return number>0 ? 1 : 0\n}\n","import getCorrectParityBitValues from \"utils/getCorrectParityBitValues\"\n\n/**\n * given a number of bits, generate a valid data array\n * @param  numberBits number of bits\n * @return            2d data array\n */\nexport default function generateData(numberBits:number):number[] {\n  const data = [0] //set the first bit to zero for now\n\n  while(data.length < numberBits) { //while we do not have enough rows\n    data.push(Math.random()>0.5 ? 1 : 0) //push the bit\n  }\n\n  //set the value of each parity bit\n  getCorrectParityBitValues(data).forEach((value, powerOf2) => {\n    data[Math.pow(2, powerOf2)] = value //set the parity bit\n  })\n\n  //set the first bit to the parity of the whole data array\n  data[0] = data.reduce((accumulator, currentValue) => accumulator^=currentValue, 0)\n\n  return data\n}\n","import zeroOrOne from \"utils/zeroOrOne\"\n\n/**\n * given an array of data, return the correct parity bit values as an array, where the index n matches the 2^n parity bit\n * @param  data data array\n * @return      array of parity bit values\n */\nexport default function getCorrectParityBitValues(data:number[]):number[] {\n  const correctParityBitValues = []\n\n  let powerOf2 = 0\n  let parityBitIndex = Math.pow(2, powerOf2)\n  const length = data.length\n\n  while(parityBitIndex < length) { //while the parity bit is still in the data array\n    //iterate through all subsequent bits\n    let paritySum = 0\n    for(let compareBitIndex=parityBitIndex+1; compareBitIndex<length; ++compareBitIndex) {\n      if(compareBitIndex & parityBitIndex) { //if this is a parity bit for this compare bit\n        paritySum += zeroOrOne(data[compareBitIndex]) //increment by the bit value\n      }\n    }\n\n    correctParityBitValues.push(paritySum%2) //push the correct value\n\n    ++powerOf2 //increment to the next power of 2\n    parityBitIndex = Math.pow(2, powerOf2) //move to the next parity bit\n  }\n\n  return correctParityBitValues\n}\n","import React from \"react\";\nimport memoize from \"memoize-one\";\n\nimport Bit from \"Components/Bit/Bit\";\nimport ColorBinary from \"Components/ColorBinary/ColorBinary\";\nimport dec2binPadded from \"utils/dec2binPadded\";\nimport generateData from \"utils/generateData\";\nimport isPowerOf2 from \"utils/isPowerOf2\";\nimport validateDataArray from \"utils/validateDataArray\";\n\nimport \"./App.scss\";\n\ninterface AppState {\n  data: number[];\n  dataContainerInnerWidth: number;\n  mousedOverBitIndex: number;\n  numberBits: number;\n  showBinary: boolean;\n}\n\ninterface RegularParityBit {\n  bit: number;\n  bitIndex: number;\n}\n\ninterface SharedBitProps {\n  doubleError: boolean;\n  errorIndex: number;\n  height: number;\n  mousedOverBitIndex: number;\n  numColumns: number;\n  numRows: number;\n  onClickBit: Function;\n  onMouseOverBit: Function;\n  paddedBinaryLength: number;\n  width: number;\n}\n\nconst MAX_ROW_CELL_SHOW_BINARY = 6; //maximum number of bits in a row before we stop showing binary (ie \"Current value of the parity bits\")\nconst MAX_CELL_WIDTH = 100;\n\nclass App extends React.Component<{}, AppState> {\n  dataContainerInnerRef: React.RefObject<HTMLDivElement>;\n\n  constructor(props: {}) {\n    super(props);\n\n    const numberBits = 16;\n\n    this.state = {\n      data: generateData(numberBits),\n      dataContainerInnerWidth: Math.sqrt(16) * MAX_CELL_WIDTH,\n      mousedOverBitIndex: -1,\n      numberBits,\n      showBinary: true,\n    };\n\n    this.dataContainerInnerRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.resize();\n    window.addEventListener(\"resize\", this.resize);\n  }\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.resize);\n  }\n\n  calculations = memoize((data: number[]) => {\n    const numColumns = Math.ceil(Math.sqrt(data.length));\n\n    //pull out the regular parity bits\n    const regularParityBits: RegularParityBit[] = data\n      .filter((bit, bitIndex) => isPowerOf2(bitIndex))\n      .map((bit, powerOf2) => ({\n        bit, //track the bit value\n        bitIndex: Math.pow(2, powerOf2), //track the original bit index\n      }))\n      .reverse(); //reverse them so we can put them in binary order\n    const totalNumParityBits = regularParityBits.length + 1;\n\n    return {\n      ...validateDataArray(this.state.data), //doubleError, errorIndex, parity\n      efficiency: (\n        (100 * (data.length - totalNumParityBits)) /\n        data.length\n      ).toFixed(2),\n      numColumns,\n      numRows: Math.ceil(data.length / numColumns),\n      paddedBinaryLength: Math.ceil(Math.log(data.length) / Math.log(2)),\n      regularParityBits,\n      totalNumParityBits,\n    };\n  });\n\n  getBitDimensions = memoize(\n    (dataContainerInnerWidth: number, windowInnerWidth: number) => {\n      //if the screen is too small, set the width to 1/4 of the available width\n      //else cap the bit width\n      const dimension = Math.min(dataContainerInnerWidth / 4, MAX_CELL_WIDTH);\n\n      return {\n        bitHeight: dimension,\n        bitWidth: dimension,\n      };\n    }\n  );\n\n  generateNewData = (numberBits: number) =>\n    this.setState({\n      data: generateData(numberBits),\n      numberBits,\n    });\n\n  getMousedOverText = (paddedBinaryLength: number) => {\n    const { mousedOverBitIndex } = this.state;\n\n    if (this.state.mousedOverBitIndex >= 0) {\n      //if there is a bit being hovered over\n      const returnArray = [<br />];\n\n      return returnArray.map((element, index) => (\n        <div key={index}>{element}</div>\n      ));\n    }\n  };\n\n  getRegularParityBitsExplanation = (\n    doubleError: boolean,\n    errorIndex: number,\n    paddedBinaryLength: number,\n    regularParityBits: RegularParityBit[],\n    sharedBitProps: SharedBitProps\n  ) => {\n    if (doubleError) {\n      //if there is a 2-bit error\n      return (\n        <React.Fragment>\n          <br />\n          <div className=\"colorErrorBit errorDetected\">\n            Обнаружена двойная ошибка!\n          </div>\n          <div\n            className=\"regularParityBitsContainer\"\n            onMouseLeave={(e) => this.setState({ mousedOverBitIndex: -1 })}\n          >\n            {regularParityBits.map((regularParityBit) => (\n              <Bit\n                key={regularParityBit.bitIndex}\n                absolutePositioned={false}\n                bit={regularParityBit.bitIndex & errorIndex ? 1 : 0}\n                bitIndex={regularParityBit.bitIndex}\n                isCell={true}\n                showBinary={\n                  regularParityBits.length <= MAX_ROW_CELL_SHOW_BINARY\n                }\n                {...sharedBitProps}\n              />\n            ))}\n          </div>\n        </React.Fragment>\n      );\n    } else if (errorIndex > 0) {\n      //else if there is a single bit error\n      return (\n        <React.Fragment>\n          <br />\n          <div className=\"colorErrorBit errorDetected\">\n            Обнаружена одиночная ошибка!\n          </div>\n          <div\n            className=\"regularParityBitsContainer\"\n            onMouseLeave={(e) => this.setState({ mousedOverBitIndex: -1 })}\n          >\n            {regularParityBits.map((regularParityBit) => (\n              <Bit\n                key={regularParityBit.bitIndex}\n                absolutePositioned={false}\n                bit={regularParityBit.bitIndex & errorIndex ? 1 : 0}\n                bitIndex={regularParityBit.bitIndex}\n                isCell={true}\n                showBinary={\n                  regularParityBits.length <= MAX_ROW_CELL_SHOW_BINARY\n                }\n                {...sharedBitProps}\n              />\n            ))}\n          </div>\n\n          <br />\n\n          <div>\n            <button\n              onClick={(e) => this.swapIncorrectBit(doubleError, errorIndex)}\n              disabled={errorIndex === 0 || doubleError}\n            >\n              Поменять некорректный({errorIndex})\n            </button>\n          </div>\n        </React.Fragment>\n      );\n    }\n  };\n\n  highlightBit = (bitIndex: number) =>\n    this.setState({ mousedOverBitIndex: bitIndex });\n\n  resize = () => {\n    if (this.dataContainerInnerRef.current) {\n      this.setState({\n        dataContainerInnerWidth: this.dataContainerInnerRef.current.clientWidth,\n      });\n    }\n  };\n\n  swapIncorrectBit = (doubleError: boolean, errorIndex: number) => {\n    if (errorIndex > 0 && doubleError === false) {\n      //if this is a 1-bit error to swap\n      this.switchBit(errorIndex);\n    }\n  };\n\n  switchBit = (bitIndex: number) => {\n    const dataCopy = this.state.data.slice();\n    dataCopy[bitIndex] = dataCopy[bitIndex] > 0 ? 0 : 1; //switch the bit\n    this.setState({ data: dataCopy });\n  };\n\n  render() {\n    const { data, dataContainerInnerWidth, mousedOverBitIndex, showBinary } =\n      this.state;\n\n    const { bitHeight, bitWidth } = this.getBitDimensions(\n      dataContainerInnerWidth,\n      window.innerWidth\n    );\n\n    const {\n      doubleError,\n      efficiency,\n      errorIndex,\n      numColumns,\n      numRows,\n      paddedBinaryLength,\n      regularParityBits,\n      totalNumParityBits,\n      parity,\n    } = this.calculations(data);\n\n    const sharedBitProps: SharedBitProps = {\n      doubleError,\n      errorIndex,\n      height: bitHeight,\n      mousedOverBitIndex,\n      numColumns,\n      numRows,\n      onClickBit: this.switchBit,\n      onMouseOverBit: this.highlightBit,\n      paddedBinaryLength,\n      width: bitWidth,\n    };\n\n    return (\n      <div id=\"App\">\n        <section id=\"content\">\n          <div id=\"interactiveContainer\">\n            <div id=\"clickSwapMessage\">\n              Нажмите на бит, чтобы поменять его значение\n            </div>\n\n            <div id=\"dataContainer\">\n              <div ref={this.dataContainerInnerRef}>\n                <div\n                  id=\"cellsContainer\"\n                  onMouseLeave={(e) =>\n                    this.setState({ mousedOverBitIndex: -1 })\n                  }\n                  style={{\n                    height: bitHeight * numRows,\n                    width: bitWidth * numColumns,\n                  }}\n                >\n                  {data.map((bit, bitIndex) => (\n                    <Bit\n                      key={bitIndex}\n                      absolutePositioned={true}\n                      bit={bit}\n                      bitIndex={bitIndex}\n                      isCell={true}\n                      showBinary={showBinary}\n                      {...sharedBitProps}\n                    />\n                  ))}\n                </div>\n              </div>\n\n              <br />\n\n              <br />\n\n              <div>\n                <span\n                  id=\"rawMessageContainer\"\n                  onMouseLeave={(e) =>\n                    this.setState({ mousedOverBitIndex: -1 })\n                  }\n                >\n                  {data.map((bit, bitIndex) => (\n                    <Bit\n                      key={bitIndex}\n                      absolutePositioned={false}\n                      bit={bit}\n                      bitIndex={bitIndex}\n                      isCell={false}\n                      {...sharedBitProps}\n                    />\n                  ))}\n                </span>\n              </div>\n            </div>\n\n            <div id=\"legend\">\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorZerothBit\"></span>{\" \"}\n                <span className=\"legendText\">Бит общей чётности</span>\n              </span>\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorParityBit\"></span>{\" \"}\n                <span className=\"legendText\">Контрольный бит</span>\n              </span>\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorDataBit\"></span>{\" \"}\n                <span className=\"legendText\">Бит данных</span>\n              </span>\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorErrorBit\"></span>{\" \"}\n                <span className=\"legendText\">Бит с ошибкой</span>\n              </span>\n            </div>\n          </div>\n\n          <div id=\"sidebar\">\n            <div>\n              <div>\n                <b>Сгенерировать новые данные: </b>\n              </div>\n\n              <br />\n\n              <div>\n                <span>\n                  {[2, 4, 8].map((newDimension) => (\n                    <button\n                      key={newDimension}\n                      className=\"grouped\"\n                      onClick={(e) =>\n                        this.generateNewData(newDimension * newDimension)\n                      }\n                    >\n                      {newDimension * newDimension}\n                    </button>\n                  ))}\n                </span>{\" \"}\n                |{\" \"}\n                <input\n                  id=\"customNumberBits\"\n                  type=\"number\"\n                  step=\"1\"\n                  min=\"1\"\n                  value={this.state.numberBits}\n                  onChange={(e) =>\n                    this.generateNewData(parseInt(e.target.value))\n                  }\n                />{\" \"}\n                бита\n              </div>\n            </div>\n\n            <hr />\n\n            <b>Эффективность </b>\n            <p>\n              Поскольку у нас есть несколько битов четности, не все биты можно\n              использовать для передачи данных. Текущая эффективность:\n            </p>\n            <div>\n              {data.length - totalNumParityBits} бита данных / {data.length}{\" \"}\n              всего = <b>{efficiency}%</b>\n            </div>\n\n            <hr />\n\n            <div>\n              <b>Общая четность сообщения:</b> {parity} (\n              {parity === 1 ? \"нечётный\" : \"чётный\"})\n            </div>\n\n            <br />\n\n            <div>\n              <b>Текущие значения контрольных битов</b>\n            </div>\n            <div\n              className=\"regularParityBitsContainer\"\n              onMouseLeave={(e) => this.setState({ mousedOverBitIndex: -1 })}\n            >\n              {regularParityBits.map((parityBit) => (\n                <Bit\n                  key={parityBit.bitIndex}\n                  absolutePositioned={false}\n                  bit={parityBit.bit}\n                  bitIndex={parityBit.bitIndex}\n                  isCell={true}\n                  showBinary={\n                    regularParityBits.length <= MAX_ROW_CELL_SHOW_BINARY\n                  }\n                  {...sharedBitProps}\n                />\n              ))}\n            </div>\n\n            {this.getRegularParityBitsExplanation(\n              doubleError,\n              errorIndex,\n              paddedBinaryLength,\n              regularParityBits,\n              sharedBitProps\n            )}\n\n            <hr />\n\n            <div>{this.getMousedOverText(paddedBinaryLength)}</div>\n          </div>\n        </section>\n\n        <footer>\n          <p>\n            <br></br>\n            <br></br>\n            <br></br>\n            <br></br>\n            <br></br>\n            <br></br>\n            <br></br>\n          </p>\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import zeroOrOne from \"utils/zeroOrOne\"\n\n/**\n * given a data array, return whether a double error is detected, the error index, and the overall parity\n * @param  data data array\n * @return      an object that says whether a double error is detected, the error index, and the overall parity\n */\nexport default function validateDataArray(\n  data:number[]\n):{\n  doubleError: boolean,\n  errorIndex: number,\n  parity: number,\n} {\n  let errorIndex = 0\n  let parity = 0\n\n  data.forEach((bit, bitIndex) => {\n    const value = zeroOrOne(bit)\n    if(value === 1) { //if this bit is one\n      errorIndex ^= bitIndex //XOR the bit index\n    }\n\n    parity ^= value //get the parity of the data (this includes the first overall parity bit)\n  })\n\n  return {\n    doubleError: parity===0 && errorIndex > 0, //if the parity is correct AND we have an error, this means we detected a 2 bit error\n    errorIndex,\n    parity,\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}