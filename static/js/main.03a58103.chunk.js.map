{"version":3,"sources":["utils/dec2binPadded.ts","utils/zeroPadString.ts","utils/dec2bin.ts","utils/isPowerOf2.ts","Components/Bit/Bit.tsx","Components/ColorBinary/ColorBinary.tsx","utils/zeroOrOne.ts","utils/generateData.ts","utils/getCorrectParityBitValues.ts","App.tsx","utils/validateDataArray.ts","serviceWorker.ts","index.tsx"],"names":["dec2binPadded","number","length","string","right","zeroPadString","toString","isPowerOf2","num","Bit","getColorClassName","props","bitIndex","doubleError","errorIndex","getOpacityClassName","mousedOverBitIndex","this","absolutePositioned","bit","height","isCell","numRows","numColumns","onClickBit","onMouseOverBit","paddedBinaryLength","showBinary","width","colorClassName","opacityClassName","absolutePosition","position","left","top","Math","floor","className","onClick","e","onMouseOver","style","paddingBottom","React","Component","ColorBinary","chars","split","map","char","charIndex","key","zeroOrOne","generateData","numberBits","data","push","random","correctParityBitValues","powerOf2","parityBitIndex","pow","paritySum","compareBitIndex","getCorrectParityBitValues","forEach","value","reduce","accumulator","currentValue","App","dataContainerInnerRef","calculations","memoize","ceil","sqrt","regularParityBits","filter","reverse","totalNumParityBits","parity","validateDataArray","state","efficiency","toFixed","log","getBitDimensions","dataContainerInnerWidth","windowInnerWidth","dimension","min","bitHeight","bitWidth","generateNewData","setState","getMousedOverText","returnArray","element","index","getRegularParityBitsExplanation","sharedBitProps","Fragment","onMouseLeave","regularParityBit","swapIncorrectBit","disabled","highlightBit","resize","current","clientWidth","switchBit","dataCopy","slice","createRef","window","addEventListener","removeEventListener","innerWidth","id","ref","newDimension","type","step","onChange","parseInt","target","parityBit","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.03a58103.chunk.js","sourcesContent":["import dec2bin from \"utils/dec2bin\"\nimport zeroPadString from \"utils/zeroPadString\"\n\n/**\n * given a number a desired length, return the zero padded binary string representation\n * @param  number input number\n * @param  length desired string length to zero pad to\n * @return        zero padded binary string\n */\nexport default function dec2binPadded(number:number, length:number) {\n  return zeroPadString(dec2bin(number), length)\n}\n","/**\n * given a string and desired length, zero pad the string if it is shorted than the desired length\n * @param  string input string\n * @param  length desired length\n * @param  right  if true, pad on the right, else pad on the left\n * @return        zero padded string\n */\nexport default function zeroPadString(string:string, length:number, right?:boolean) {\n  while(string.length < length) {\n    if(right) {\n      string = string + \"0\"\n    }\n    else {\n      string = \"0\" + string\n    }\n  }\n\n  return string\n}\n","/**\n * converts a base 10 number into it's binary string representation\n * taken from https://stackoverflow.com/questions/9939760/how-do-i-convert-an-integer-to-binary-in-javascript\n * @param  dec base 10 number\n * @return     binary string representation\n */\nexport default function dec2bin(dec:number) {\n  return (dec >>> 0).toString(2)\n}\n","/**\n * given a number, return true/false whether it is a power of 2, including 1, excluding 0\n * taken from https://stackoverflow.com/questions/1053582/how-does-this-bitwise-operation-check-for-a-power-of-2/1053594#1053594\n * @param  num input number\n * @return     true/false whether the number is a power of 2\n */\nexport default function isPowerOf2(num:number) {\n  if(num === 0) {\n    return false\n  }\n\n  return !(num & (num - 1)) //bitwise AND the number and one less than it\n}\n","import React from 'react';\n\nimport dec2binPadded from \"utils/dec2binPadded\"\nimport isPowerOf2 from \"utils/isPowerOf2\"\nimport \"./bit.scss\"\n\ninterface BitProps {\n  absolutePositioned:boolean,\n  bit: number,\n  bitIndex: number,\n  doubleError: boolean,\n  errorIndex: number,\n  height: number,\n  isCell: boolean,\n  mousedOverBitIndex:number,\n  numColumns: number,\n  numRows: number,\n  onClickBit: Function,\n  onMouseOverBit: Function,\n  paddedBinaryLength: number,\n  showBinary?: boolean,\n  width: number,\n}\n\ninterface AbsolutePosition {\n  position: \"absolute\" | \"relative\",\n  left?: string,\n  top?: string,\n}\n\nclass Bit extends React.Component<BitProps,{}> {\n  getColorClassName = () => {\n    const {\n      bitIndex,\n      doubleError,\n      errorIndex,\n    } = this.props\n\n    if(bitIndex === 0) { //if this is the 0th cell\n      return \"colorZerothBit\"\n    }\n    else if(doubleError===false && errorIndex===bitIndex) {\n      return \"colorErrorBit\"\n    }\n    else if(isPowerOf2(bitIndex)) { //if this is a parity bit\n      // if( //if this is a parity bit for the moused over cell\n      //   mousedOverBitIndex>=0\n      //   && bitIndex & mousedOverBitIndex\n      // ) {\n      //   return \"relatedParityBit\"\n      // }\n\n      return \"colorParityBit\"\n    }\n    // else if( //if the moused over cell is a parity bit for this cell\n    //   mousedOverBitIndex>=0 //there is a cell being moused over\n    //   && isPowerOf2(mousedOverBitIndex) //the moused over cell is a parity bit\n    //   && bitIndex & mousedOverBitIndex //the ANDed bitwise operation produces a number\n    // ) {\n    //   return \"colorDataBit\" //return \"coveredByParityBit\"\n    // }\n    // else if(bitIndex === mousedOverBitIndex) { //if this is the cell being moused over\n    //   return \"colorMousedOver\"\n    // }\n\n    return \"colorDataBit\"\n  }\n\n  getOpacityClassName = () => {\n    const {\n      bitIndex,\n      mousedOverBitIndex,\n    } = this.props\n\n    if(bitIndex === 0) { //if this is the 0th cell\n      if(mousedOverBitIndex > 0) {\n        return \"opacityDimmed\"\n      }\n      return \"\"\n    }\n    else if( //if this is a parity bit for the moused over cell\n      isPowerOf2(bitIndex)\n      && mousedOverBitIndex>=0\n      && bitIndex & mousedOverBitIndex\n    ) {\n      return \"\"\n    }\n    else if( //if the moused over cell is a parity bit for this cell\n      mousedOverBitIndex>=0 //there is a cell being moused over\n      && isPowerOf2(mousedOverBitIndex) //the moused over cell is a parity bit\n      && bitIndex & mousedOverBitIndex //the ANDed bitwise operation produces a number\n    ) {\n      return \"\"\n    }\n    else if(\n      mousedOverBitIndex >= 0\n      && mousedOverBitIndex !== bitIndex\n    ) {\n      return \"opacityDimmed\"\n    }\n\n    return \"\"\n  }\n\n  render() {\n    const {\n      absolutePositioned,\n      bit,\n      bitIndex,\n      height,\n      isCell,\n      numRows,\n      numColumns,\n      onClickBit,\n      onMouseOverBit,\n      paddedBinaryLength,\n      showBinary,\n      width,\n    } = this.props\n\n    const colorClassName = this.getColorClassName()\n    const opacityClassName = this.getOpacityClassName()\n\n    if(isCell) {\n      const absolutePosition:AbsolutePosition = {position: \"relative\"}\n      if(absolutePositioned) {\n        absolutePosition.position = \"absolute\"\n        absolutePosition.left = (100 * (bitIndex % numColumns) / numColumns).toString()+\"%\" //TODO memoize this\n        absolutePosition.top = (100 * Math.floor(bitIndex/numColumns) / numRows).toString()+\"%\"\n      }\n\n      return (\n        <span\n          className={`bit cell ${colorClassName} ${opacityClassName}` }\n          onClick={e => onClickBit(bitIndex)}\n          onMouseOver={e => onMouseOverBit(bitIndex)}\n          style={{\n            height: height - 2,\n            width: width - 2,\n            ...absolutePosition,\n          }}\n        >\n          <div className=\"value\" style={{\n            paddingBottom: showBinary ? \"0.25em\" : \"0\"\n          }}>{bit}</div>\n          <div className=\"binaryBitIndex\">{showBinary ? dec2binPadded(bitIndex, paddedBinaryLength) : null}</div>\n          <div className=\"bitIndex\">{bitIndex}</div>\n        </span>\n      )\n    }\n\n    return (\n      <span\n        className={`bit messageBit ${colorClassName} ${opacityClassName}`}\n        onClick={e => onClickBit(bitIndex)}\n        onMouseOver={e => onMouseOverBit(bitIndex)}\n      >\n        {bit}\n      </span>\n    )\n  }\n}\n\nexport default Bit\n","import React from 'react'\n\nimport dec2binPadded from \"utils/dec2binPadded\"\nimport \"./colorBinary.scss\"\n\ninterface ColorBinaryProps {\n  number: number,\n  paddedBinaryLength: number,\n}\n\nconst ColorBinary = (props:ColorBinaryProps) => {\n  const chars = dec2binPadded(props.number, props.paddedBinaryLength).split(\"\")\n\n  return (\n    <span>{chars.map((char, charIndex) =>\n      <span className={\"colorBinary\" + char} key={charIndex}>{char}</span>\n    )}</span>\n  )\n}\n\nexport default ColorBinary\n","/**\n * return 1 if the number is greater than 0, else return 0\n * @param  number input number\n * @return        0 or 1\n */\nexport default function zeroOrOne(number:number) {\n  return number>0 ? 1 : 0\n}\n","import getCorrectParityBitValues from \"utils/getCorrectParityBitValues\"\n\n/**\n * given a number of bits, generate a valid data array\n * @param  numberBits number of bits\n * @return            2d data array\n */\nexport default function generateData(numberBits:number):number[] {\n  const data = [0] //set the first bit to zero for now\n\n  while(data.length < numberBits) { //while we do not have enough rows\n    data.push(Math.random()>0.5 ? 1 : 0) //push the bit\n  }\n\n  //set the value of each parity bit\n  getCorrectParityBitValues(data).forEach((value, powerOf2) => {\n    data[Math.pow(2, powerOf2)] = value //set the parity bit\n  })\n\n  //set the first bit to the parity of the whole data array\n  data[0] = data.reduce((accumulator, currentValue) => accumulator^=currentValue, 0)\n\n  return data\n}\n","import zeroOrOne from \"utils/zeroOrOne\"\n\n/**\n * given an array of data, return the correct parity bit values as an array, where the index n matches the 2^n parity bit\n * @param  data data array\n * @return      array of parity bit values\n */\nexport default function getCorrectParityBitValues(data:number[]):number[] {\n  const correctParityBitValues = []\n\n  let powerOf2 = 0\n  let parityBitIndex = Math.pow(2, powerOf2)\n  const length = data.length\n\n  while(parityBitIndex < length) { //while the parity bit is still in the data array\n    //iterate through all subsequent bits\n    let paritySum = 0\n    for(let compareBitIndex=parityBitIndex+1; compareBitIndex<length; ++compareBitIndex) {\n      if(compareBitIndex & parityBitIndex) { //if this is a parity bit for this compare bit\n        paritySum += zeroOrOne(data[compareBitIndex]) //increment by the bit value\n      }\n    }\n\n    correctParityBitValues.push(paritySum%2) //push the correct value\n\n    ++powerOf2 //increment to the next power of 2\n    parityBitIndex = Math.pow(2, powerOf2) //move to the next parity bit\n  }\n\n  return correctParityBitValues\n}\n","import React from \"react\";\nimport memoize from \"memoize-one\";\n\nimport Bit from \"Components/Bit/Bit\";\nimport ColorBinary from \"Components/ColorBinary/ColorBinary\";\nimport dec2binPadded from \"utils/dec2binPadded\";\nimport generateData from \"utils/generateData\";\nimport isPowerOf2 from \"utils/isPowerOf2\";\nimport validateDataArray from \"utils/validateDataArray\";\n\nimport \"./App.scss\";\n\ninterface AppState {\n  data: number[];\n  dataContainerInnerWidth: number;\n  mousedOverBitIndex: number;\n  numberBits: number;\n  showBinary: boolean;\n}\n\ninterface RegularParityBit {\n  bit: number;\n  bitIndex: number;\n}\n\ninterface SharedBitProps {\n  doubleError: boolean;\n  errorIndex: number;\n  height: number;\n  mousedOverBitIndex: number;\n  numColumns: number;\n  numRows: number;\n  onClickBit: Function;\n  onMouseOverBit: Function;\n  paddedBinaryLength: number;\n  width: number;\n}\n\nconst MAX_ROW_CELL_SHOW_BINARY = 6; //maximum number of bits in a row before we stop showing binary (ie \"Current value of the parity bits\")\nconst MAX_CELL_WIDTH = 100;\n\nclass App extends React.Component<{}, AppState> {\n  dataContainerInnerRef: React.RefObject<HTMLDivElement>;\n\n  constructor(props: {}) {\n    super(props);\n\n    const numberBits = 16;\n\n    this.state = {\n      data: generateData(numberBits),\n      dataContainerInnerWidth: Math.sqrt(16) * MAX_CELL_WIDTH,\n      mousedOverBitIndex: -1,\n      numberBits,\n      showBinary: true,\n    };\n\n    this.dataContainerInnerRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.resize();\n    window.addEventListener(\"resize\", this.resize);\n  }\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.resize);\n  }\n\n  calculations = memoize((data: number[]) => {\n    const numColumns = Math.ceil(Math.sqrt(data.length));\n\n    //pull out the regular parity bits\n    const regularParityBits: RegularParityBit[] = data\n      .filter((bit, bitIndex) => isPowerOf2(bitIndex))\n      .map((bit, powerOf2) => ({\n        bit, //track the bit value\n        bitIndex: Math.pow(2, powerOf2), //track the original bit index\n      }))\n      .reverse(); //reverse them so we can put them in binary order\n    const totalNumParityBits = regularParityBits.length + 1;\n\n    return {\n      ...validateDataArray(this.state.data), //doubleError, errorIndex, parity\n      efficiency: (\n        (100 * (data.length - totalNumParityBits)) /\n        data.length\n      ).toFixed(2),\n      numColumns,\n      numRows: Math.ceil(data.length / numColumns),\n      paddedBinaryLength: Math.ceil(Math.log(data.length) / Math.log(2)),\n      regularParityBits,\n      totalNumParityBits,\n    };\n  });\n\n  getBitDimensions = memoize(\n    (dataContainerInnerWidth: number, windowInnerWidth: number) => {\n      //if the screen is too small, set the width to 1/4 of the available width\n      //else cap the bit width\n      const dimension = Math.min(dataContainerInnerWidth / 4, MAX_CELL_WIDTH);\n\n      return {\n        bitHeight: dimension,\n        bitWidth: dimension,\n      };\n    }\n  );\n\n  generateNewData = (numberBits: number) =>\n    this.setState({\n      data: generateData(numberBits),\n      numberBits,\n    });\n\n  getMousedOverText = (paddedBinaryLength: number) => {\n    const { mousedOverBitIndex } = this.state;\n\n    if (this.state.mousedOverBitIndex >= 0) {\n      //if there is a bit being hovered over\n      const returnArray = [\n        <span>\n          You are hovering over bit {mousedOverBitIndex}\n          <span className=\"floatRight\">\n            (binary{\" \"}\n            <ColorBinary\n              number={mousedOverBitIndex}\n              paddedBinaryLength={paddedBinaryLength}\n            />\n            )\n          </span>\n        </span>,\n        <br />,\n      ];\n\n      if (mousedOverBitIndex === 0) {\n        returnArray.push(\n          <span>\n            It tracks the parity of the rest of the message. Including this bit,\n            the overall parity of the message should be 0 (even). If the other\n            parity bits detect an error AND the parity of the whole message is\n            odd, we assume there is a 1-bit error. If the other parity bits\n            detect an error AND the parity of the whole message is even, we\n            assume there is a 2-bit error.\n          </span>\n        );\n      } else if (isPowerOf2(mousedOverBitIndex)) {\n        //the moused over bit is a parity bit\n        returnArray.push(\n          <span>\n            It tracks all bits with a 1 in binary position{\" \"}\n            {Math.log(mousedOverBitIndex) / Math.log(2)}\n          </span>\n        );\n      } else {\n        //else this is a regular bit. find it's parity bits\n        this.state.data.forEach((bit, bitIndex) => {\n          if (\n            bitIndex !== mousedOverBitIndex && //ignore the bit we are currently moused over\n            isPowerOf2(bitIndex) && //if this is a parity bit\n            bitIndex & mousedOverBitIndex //this bit is a parity bit for our moused over bit\n          ) {\n            returnArray.push(\n              <span>\n                It is tracked by parity bit {bitIndex}\n                <span className=\"floatRight\">\n                  (binary{\" \"}\n                  <ColorBinary\n                    number={bitIndex}\n                    paddedBinaryLength={paddedBinaryLength}\n                  />\n                  )\n                </span>\n              </span>\n            );\n          }\n        });\n      }\n\n      return returnArray.map((element, index) => (\n        <div key={index}>{element}</div>\n      ));\n    }\n\n    return \"Наведите курсор на бит, чтобы узнать больше\";\n  };\n\n  getRegularParityBitsExplanation = (\n    doubleError: boolean,\n    errorIndex: number,\n    paddedBinaryLength: number,\n    regularParityBits: RegularParityBit[],\n    sharedBitProps: SharedBitProps\n  ) => {\n    if (doubleError) {\n      //if there is a 2-bit error\n      return (\n        <React.Fragment>\n          <br />\n          <div className=\"colorErrorBit errorDetected\">\n            Double Error Detected!\n          </div>\n          <div>\n            This is what the values of the parity bits should be. Since the\n            overall parity of the message is even, this means that there is a\n            2-bit error!\n          </div>\n          <div\n            className=\"regularParityBitsContainer\"\n            onMouseLeave={(e) => this.setState({ mousedOverBitIndex: -1 })}\n          >\n            {regularParityBits.map((regularParityBit) => (\n              <Bit\n                key={regularParityBit.bitIndex}\n                absolutePositioned={false}\n                bit={regularParityBit.bitIndex & errorIndex ? 1 : 0}\n                bitIndex={regularParityBit.bitIndex}\n                isCell={true}\n                showBinary={\n                  regularParityBits.length <= MAX_ROW_CELL_SHOW_BINARY\n                }\n                {...sharedBitProps}\n              />\n            ))}\n          </div>\n        </React.Fragment>\n      );\n    } else if (errorIndex > 0) {\n      //else if there is a single bit error\n      return (\n        <React.Fragment>\n          <br />\n          <div className=\"colorErrorBit errorDetected\">\n            Single Error to be Corrected!\n          </div>\n          <div>\n            This is what the values of the parity bits should be. Since the\n            overall parity of the message is odd, this means that there is a\n            1-bit error in binary position{\" \"}\n            {dec2binPadded(errorIndex, paddedBinaryLength)}, ie position{\" \"}\n            {errorIndex}\n          </div>\n          <div\n            className=\"regularParityBitsContainer\"\n            onMouseLeave={(e) => this.setState({ mousedOverBitIndex: -1 })}\n          >\n            {regularParityBits.map((regularParityBit) => (\n              <Bit\n                key={regularParityBit.bitIndex}\n                absolutePositioned={false}\n                bit={regularParityBit.bitIndex & errorIndex ? 1 : 0}\n                bitIndex={regularParityBit.bitIndex}\n                isCell={true}\n                showBinary={\n                  regularParityBits.length <= MAX_ROW_CELL_SHOW_BINARY\n                }\n                {...sharedBitProps}\n              />\n            ))}\n          </div>\n\n          <br />\n\n          <div>\n            <button\n              onClick={(e) => this.swapIncorrectBit(doubleError, errorIndex)}\n              disabled={errorIndex === 0 || doubleError}\n            >\n              Swap Incorrect Bit ({errorIndex})\n            </button>\n          </div>\n        </React.Fragment>\n      );\n    }\n  };\n\n  highlightBit = (bitIndex: number) =>\n    this.setState({ mousedOverBitIndex: bitIndex });\n\n  resize = () => {\n    if (this.dataContainerInnerRef.current) {\n      this.setState({\n        dataContainerInnerWidth: this.dataContainerInnerRef.current.clientWidth,\n      });\n    }\n  };\n\n  swapIncorrectBit = (doubleError: boolean, errorIndex: number) => {\n    if (errorIndex > 0 && doubleError === false) {\n      //if this is a 1-bit error to swap\n      this.switchBit(errorIndex);\n    }\n  };\n\n  switchBit = (bitIndex: number) => {\n    const dataCopy = this.state.data.slice();\n    dataCopy[bitIndex] = dataCopy[bitIndex] > 0 ? 0 : 1; //switch the bit\n    this.setState({ data: dataCopy });\n  };\n\n  render() {\n    const { data, dataContainerInnerWidth, mousedOverBitIndex, showBinary } =\n      this.state;\n\n    const { bitHeight, bitWidth } = this.getBitDimensions(\n      dataContainerInnerWidth,\n      window.innerWidth\n    );\n\n    const {\n      doubleError,\n      efficiency,\n      errorIndex,\n      numColumns,\n      numRows,\n      paddedBinaryLength,\n      regularParityBits,\n      totalNumParityBits,\n      parity,\n    } = this.calculations(data);\n\n    const sharedBitProps: SharedBitProps = {\n      doubleError,\n      errorIndex,\n      height: bitHeight,\n      mousedOverBitIndex,\n      numColumns,\n      numRows,\n      onClickBit: this.switchBit,\n      onMouseOverBit: this.highlightBit,\n      paddedBinaryLength,\n      width: bitWidth,\n    };\n\n    return (\n      <div id=\"App\">\n        <section id=\"content\">\n          <div id=\"interactiveContainer\">\n            <div id=\"clickSwapMessage\">\n              Нажмите на бит, чтобы поменять его значение\n            </div>\n\n            <div id=\"dataContainer\">\n              <div ref={this.dataContainerInnerRef}>\n                <div\n                  id=\"cellsContainer\"\n                  onMouseLeave={(e) =>\n                    this.setState({ mousedOverBitIndex: -1 })\n                  }\n                  style={{\n                    height: bitHeight * numRows,\n                    width: bitWidth * numColumns,\n                  }}\n                >\n                  {data.map((bit, bitIndex) => (\n                    <Bit\n                      key={bitIndex}\n                      absolutePositioned={true}\n                      bit={bit}\n                      bitIndex={bitIndex}\n                      isCell={true}\n                      showBinary={showBinary}\n                      {...sharedBitProps}\n                    />\n                  ))}\n                </div>\n              </div>\n\n              <br />\n\n              <br />\n\n              <div>\n                <span\n                  id=\"rawMessageContainer\"\n                  onMouseLeave={(e) =>\n                    this.setState({ mousedOverBitIndex: -1 })\n                  }\n                >\n                  {data.map((bit, bitIndex) => (\n                    <Bit\n                      key={bitIndex}\n                      absolutePositioned={false}\n                      bit={bit}\n                      bitIndex={bitIndex}\n                      isCell={false}\n                      {...sharedBitProps}\n                    />\n                  ))}\n                </span>\n              </div>\n            </div>\n\n            <div id=\"legend\">\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorZerothBit\"></span>{\" \"}\n                <span className=\"legendText\">Бит общей чётности</span>\n              </span>\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorParityBit\"></span>{\" \"}\n                <span className=\"legendText\">Бит чётности</span>\n              </span>\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorDataBit\"></span>{\" \"}\n                <span className=\"legendText\">Бит данных</span>\n              </span>\n              <span className=\"legendKey\">\n                <span className=\"legendSquare colorErrorBit\"></span>{\" \"}\n                <span className=\"legendText\">Бит с ошибкой</span>\n              </span>\n            </div>\n          </div>\n\n          <div id=\"sidebar\">\n            <div>\n              <div>\n                <b>Сгенерировать новые данные: </b>\n              </div>\n\n              <br />\n\n              <div>\n                <span>\n                  {[2, 4, 8].map((newDimension) => (\n                    <button\n                      key={newDimension}\n                      className=\"grouped\"\n                      onClick={(e) =>\n                        this.generateNewData(newDimension * newDimension)\n                      }\n                    >\n                      {newDimension * newDimension}\n                    </button>\n                  ))}\n                </span>{\" \"}\n                |{\" \"}\n                <input\n                  id=\"customNumberBits\"\n                  type=\"number\"\n                  step=\"1\"\n                  min=\"1\"\n                  value={this.state.numberBits}\n                  onChange={(e) =>\n                    this.generateNewData(parseInt(e.target.value))\n                  }\n                />{\" \"}\n                бита\n              </div>\n            </div>\n\n            <hr />\n\n            <b>Эффективность </b>\n            <p>\n              Поскольку у нас есть несколько битов четности, не все биты можно\n              использовать для передачи данных. Текущая эффективность:\n            </p>\n            <div>\n              {data.length - totalNumParityBits} бита данных / {data.length}{\" \"}\n              всего = <b>{efficiency}%</b>\n            </div>\n\n            <hr />\n\n            <div>\n              <b>Общая четность сообщения:</b> {parity} (\n              {parity === 1 ? \"нечётный\" : \"чётный\"})\n            </div>\n\n            <br />\n\n            <div>\n              <b>Текущие значения битов чётности</b>\n            </div>\n            <div\n              className=\"regularParityBitsContainer\"\n              onMouseLeave={(e) => this.setState({ mousedOverBitIndex: -1 })}\n            >\n              {regularParityBits.map((parityBit) => (\n                <Bit\n                  key={parityBit.bitIndex}\n                  absolutePositioned={false}\n                  bit={parityBit.bit}\n                  bitIndex={parityBit.bitIndex}\n                  isCell={true}\n                  showBinary={\n                    regularParityBits.length <= MAX_ROW_CELL_SHOW_BINARY\n                  }\n                  {...sharedBitProps}\n                />\n              ))}\n            </div>\n\n            {this.getRegularParityBitsExplanation(\n              doubleError,\n              errorIndex,\n              paddedBinaryLength,\n              regularParityBits,\n              sharedBitProps\n            )}\n\n            <hr />\n\n            <div>{this.getMousedOverText(paddedBinaryLength)}</div>\n          </div>\n        </section>\n\n        <footer>\n          <p>\n            <br></br>\n            <br></br>\n            <br></br>\n            <br></br>\n            <br></br>\n          </p>\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import zeroOrOne from \"utils/zeroOrOne\"\n\n/**\n * given a data array, return whether a double error is detected, the error index, and the overall parity\n * @param  data data array\n * @return      an object that says whether a double error is detected, the error index, and the overall parity\n */\nexport default function validateDataArray(\n  data:number[]\n):{\n  doubleError: boolean,\n  errorIndex: number,\n  parity: number,\n} {\n  let errorIndex = 0\n  let parity = 0\n\n  data.forEach((bit, bitIndex) => {\n    const value = zeroOrOne(bit)\n    if(value === 1) { //if this bit is one\n      errorIndex ^= bitIndex //XOR the bit index\n    }\n\n    parity ^= value //get the parity of the data (this includes the first overall parity bit)\n  })\n\n  return {\n    doubleError: parity===0 && errorIndex > 0, //if the parity is correct AND we have an error, this means we detected a 2 bit error\n    errorIndex,\n    parity,\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}